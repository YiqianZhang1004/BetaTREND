ggplot2::theme(
plot.title = element_text(face = "bold", size = 18),
plot.subtitle = element_text(size = 14, margin = margin(b = 10)),
axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
print(p)
}
return(list(
projection_scores = y_hat,
gradient_direction = v_hat,
PCoA_coordinates = E,
adjusted_R2 = adj_r_squared,
p_value = p_value,
plot = p,
variance_explained = var_explained
))
}
timepoint <- as.numeric(sample_data(ps1)[["timepoint"]])
keep <- !is.na(timepoint)
ps_filt <- prune_samples(keep, ps1)
timepoint_filt <- as.numeric(sample_data(ps_filt)[["timepoint"]])
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, timepoint_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
cjtt_u_test(dist_bray_filt, timepoint_filt, var_method = "analytic")
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
gradient_projection(dist_bray_filt, timepoint_filt)
res
load("cardiovascular_wgs.RData")
#library(devtools)
#devtools::install_github("YiqianZhang1004/BetaTREND")
library(BetaTREND)
library(phyloseq)
library(vegan)
age <- as.numeric(sample_data(ps)[["Age..years."]])
keep <- !is.na(age)
ps_filt <- prune_samples(keep, ps)
age_filt <- as.numeric(sample_data(ps_filt)[["Age..years."]] )
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, age_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores,)
cjtt_u_test(dist_bray_filt, age_filt, var_method = "analytic")
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "jackknife") Take too long
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "bootstrap")
# cjtt_u_test(dist_bray_filt, age_filt, permutation = T)
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
# --- inputs ---
D      <- dist_bray_filt          # distance matrix
trait  <- age_filt                # numeric vector
# --- 1. ordered groups (quartiles) ---
g <- cut(trait,
breaks = quantile(trait, 0:4 / 4, na.rm = TRUE),
include.lowest = TRUE,
labels = 1:4)
# --- 2. sample-level response from distance matrix ---
d1 <- cmdscale(as.dist(D), k = 1)[, 1]
# --- 3. Jonckheere–Terpstra test ---
library(clinfun)
install.packages("clinfun")
library(clinfun)
jt <- jonckheere.test(d1, g, alternative = "increasing")
d1
g
jt <- jonckheere.test(d1, g, alternative = "increasing")
g <- cut(trait,
breaks = quantile(trait, 0:4/4, na.rm = TRUE),
include.lowest = TRUE,
labels = FALSE)   # numeric 1‒4
jt <- jonckheere.test(d1, g, alternative = "increasing")
jt
g <- cut(trait,
breaks = quantile(trait, 0:4/4, na.rm = TRUE),
include.lowest = TRUE,
labels = 1:4,
ordered_result = TRUE)          # ordered factor
## or, if you already have g:
g <- factor(g, levels = 1:4, ordered = TRUE)
jt <- jonckheere.test(d1, g, alternative = "increasing")
jt
jt <- jonckheere.test(d1, g, alternative = "decreasing")
jt
age <- as.numeric(sample_data(ps)[["Age..years."]])
keep <- !is.na(age)
ps_filt <- prune_samples(keep, ps)
age_filt <- as.numeric(sample_data(ps_filt)[["Age..years."]] )
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, age_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores,)
cjtt_u_test(dist_bray_filt, age_filt, var_method = "analytic")
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "jackknife") Take too long
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "bootstrap")
# cjtt_u_test(dist_bray_filt, age_filt, permutation = T)
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
dist_bray_filt <- phyloseq::distance(ps_filt, method = "uunifrac")
res <- BetaTREND::gradient_projection(dist_bray_filt, age_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores,)
cjtt_u_test(dist_bray_filt, age_filt, var_method = "analytic")
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "jackknife") Take too long
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "bootstrap")
# cjtt_u_test(dist_bray_filt, age_filt, permutation = T)
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
dist_bray_filt <- phyloseq::distance(ps_filt, method = "wunifrac")
res <- BetaTREND::gradient_projection(dist_bray_filt, age_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores,)
cjtt_u_test(dist_bray_filt, age_filt, var_method = "analytic")
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "jackknife") Take too long
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "bootstrap")
# cjtt_u_test(dist_bray_filt, age_filt, permutation = T)
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
plot_new_projection <- function(pcoa_mat, proj,
palette = "plasma") {
if (!requireNamespace("ggplot2", quietly = TRUE))
stop("Please install the 'ggplot2' package.")
if (!requireNamespace("viridis", quietly = TRUE))
stop("Please install the 'viridis' package.")
stopifnot(nrow(pcoa_mat) == length(proj),
ncol(pcoa_mat) >= 2)
df <- data.frame(
PCoA1 = pcoa_mat[, 1],
PCoA2 = pcoa_mat[, 2],
Projection = proj
)
p <- ggplot2::ggplot(df,
ggplot2::aes(PCoA1, PCoA2, color = Projection)) +
ggplot2::geom_point(size = 3, alpha = 0.9) +
viridis::scale_color_viridis(option = palette,
direction = -1,
name = "Projection") +
ggplot2::labs(
title = "PCoA coloured by new projection scores",
x = "PCoA1",
y = "PCoA2"
) +
ggplot2::theme_classic(base_size = 14)
print(p)
invisible(p)
}
## Suppose you re-compute projection scores with your new method
new_scores <- my_trend_filtered_projection(dist_bray_filt, age_filt)
betaTREND_pipeline <- function(ps,
trait_col,
ndim    = 5,
k       = 10,
palette = "plasma",
method  = "pearson") {
if (!requireNamespace("phyloseq", quietly = TRUE))
stop("Please install the 'phyloseq' package.")
## 1 ── extract trait and filter samples -------------------------------
trait <- as.numeric(phyloseq::sample_data(ps)[[trait_col]])
keep  <- !is.na(trait)
ps_filt   <- phyloseq::prune_samples(keep, ps)
trait_flt <- as.numeric(phyloseq::sample_data(ps_filt)[[trait_col]])
## 2 ── Bray–Curtis distance on filtered object ------------------------
dist_bray <- phyloseq::distance(ps_filt, method = "bray")
## 3 ── Gradient projection -------------------------------------------
gp <- gradient_projection(dist_bray, trait_flt,
ndim   = ndim,
figure = FALSE)
## 4 ── Consistency diagnostics ---------------------------------------
metrics <- evaluate_consistency_metrics(gp$PCoA_coordinates,
gp$projection_scores,
k      = k,
method = method)
## 5 ── CJTT-U trend test ---------------------------------------------
trend <- cjtt_u_test(dist_bray, trait_flt,
var_method = "jackknife")
## 6 ── Plot: PCoA coloured by projection -----------------------------
plot_obj <- plot_new_projection(gp$PCoA_coordinates,
gp$projection_scores,
palette = palette)
invisible(list(
ps_filt  = ps_filt,
gradient = gp,
metrics  = metrics,
trend    = trend,
plot     = plot_obj
))}
gradient_projection <- function(distance_matrix, trait, ndim = 5, figure = TRUE) {
# Load required packages
if (!requireNamespace("vegan",   quietly = TRUE)) stop("Please install the 'vegan' package.")
if (figure && !requireNamespace("ggplot2", quietly = TRUE)) stop("Please install the 'ggplot2' package.")
if (figure && !requireNamespace("viridis", quietly = TRUE)) stop("Please install the 'viridis' package.")
# Input checks
if (!is.matrix(distance_matrix) && !inherits(distance_matrix, "dist"))
stop("distance_matrix must be a matrix or 'dist' object.")
n <- length(trait)
if (inherits(distance_matrix, "dist")) {
if (attr(distance_matrix, "Size") != n)
stop("trait length must match number of samples.")
} else {
if (nrow(distance_matrix) != n)
stop("trait length must match number of samples.")
}
# Step 1: PCoA
pcoa_obj <- cmdscale(distance_matrix, k = ndim, eig = TRUE)
E        <- pcoa_obj$points
eigvals  <- pcoa_obj$eig
# variance explained
var_explained <- eigvals / sum(eigvals[eigvals > 0])
var1 <- round(var_explained[1] * 100, 1)
var2 <- round(var_explained[2] * 100, 1)
# Step 2: Gradient direction
v_hat <- solve(t(E) %*% E) %*% t(E) %*% trait
y_hat <- as.vector(E %*% v_hat)
# Step 3: Global fit
lm_fit        <- lm(trait ~ E)
fstat         <- summary(lm_fit)$fstatistic
p_value       <- pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
adj_r_squared <- summary(lm_fit)$adj.r.squared
# Step 4: Figure (colour by projection scores)
p <- NULL
if (figure) {
plot_df <- data.frame(
PCoA1      = E[, 1],
PCoA2      = E[, 2],
Projection = y_hat
)
p <- ggplot2::ggplot(plot_df,
ggplot2::aes(x = PCoA1, y = PCoA2, color = Projection)) +
ggplot2::geom_point(size = 3, alpha = 0.85) +
viridis::scale_color_viridis(option = "plasma", direction = -1,
name = "Projection") +
ggplot2::labs(
title    = "Gradient-Aligned Projection in PCoA Space",
subtitle = "Colored by projection scores",
x = paste0("PCoA1 (", var1, "%)"),
y = paste0("PCoA2 (", var2, "%)")
) +
ggplot2::theme_minimal(base_size = 16) +
ggplot2::theme(
plot.title   = ggplot2::element_text(face = "bold", size = 18),
plot.subtitle= ggplot2::element_text(size = 14,
margin = ggplot2::margin(b = 10)),
axis.title   = ggplot2::element_text(size = 16),
axis.text    = ggplot2::element_text(size = 14),
legend.position = "right",
legend.title = ggplot2::element_text(size = 15),
legend.text  = ggplot2::element_text(size = 13),
panel.grid.major = ggplot2::element_blank(),
panel.grid.minor = ggplot2::element_blank()
)
print(p)
}
list(
projection_scores = y_hat,
gradient_direction = v_hat,
PCoA_coordinates   = E,
adjusted_R2        = adj_r_squared,
p_value            = p_value,
plot               = p,
variance_explained = var_explained
)
}
age <- as.numeric(sample_data(ps)[["Age..years."]])
keep <- !is.na(age)
ps_filt <- prune_samples(keep, ps)
age_filt <- as.numeric(sample_data(ps_filt)[["Age..years."]] )
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, age_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores,)
cjtt_u_test(dist_bray_filt, age_filt, var_method = "analytic")
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "jackknife") Take too long
# cjtt_u_test(dist_bray_filt, age_filt, var_method = "bootstrap")
# cjtt_u_test(dist_bray_filt, age_filt, permutation = T)
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
gradient_projection(dist_bray_filt, age_filt)
distance_matrix = dist_bray_filt
trait = age_filt
ndim =
5
figure = TRUE
if (!requireNamespace("vegan", quietly = TRUE)) stop("Please install the 'vegan' package.")
if (figure && !requireNamespace("ggplot2", quietly = TRUE)) stop("Please install the 'ggplot2' package.")
if (figure && !requireNamespace("viridis", quietly = TRUE)) stop("Please install 'viridis')")
# Input checks
if (!is.matrix(distance_matrix) && !inherits(distance_matrix, "dist")) {
stop("distance_matrix must be a matrix or 'dist' object.")
}
n <- length(trait)
if (inherits(distance_matrix, "dist")) {
if (attr(distance_matrix, "Size") != n) stop("trait length must match number of samples.")
} else {
if (nrow(distance_matrix) != n) stop("trait length must match number of samples.")
}
# Step 1: PCoA with eigenvalues
pcoa_obj <- cmdscale(distance_matrix, k = ndim, eig = TRUE)
E <- pcoa_obj$points  # coordinates
eigvals <- pcoa_obj$eig
var_explained <- eigvals / sum(eigvals[eigvals > 0])  # only positive eigenvalues
var1 <- round(var_explained[1] * 100, 1)
var2 <- round(var_explained[2] * 100, 1)
# Step 2: Gradient direction
v_hat <- solve(t(E) %*% E) %*% t(E) %*% trait
y_hat <- as.vector(E %*% v_hat)
# Step 3: Linear model fit and p-value
lm_fit <- lm(trait ~ E)
fstat <- summary(lm_fit)$fstatistic
fstat
summary(lm_fit)
pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
fstat
summary(lm_fit)$pvalue
summary(lm_fit)
summary(lm_fit)$p-value
summary(lm_fit)$Pvalue
summary(lm_fit)$coefficients[, 4]
summary(lm_fit)
pcoa_obj
E
eigvals
E
trait
lm(trait ~ E)
E
lm(trait ~ E)
summary(lm_fit)
gradient_projection <- function(distance_matrix,
trait,
ndim   = 5,
figure = TRUE,
method = c("ls", "spearman")) {
method <- match.arg(method)      # choose algorithm
if (!requireNamespace("vegan", quietly = TRUE))
stop("Please install the 'vegan' package.")
if (figure && !requireNamespace("ggplot2", quietly = TRUE))
stop("Please install the 'ggplot2' package.")
if (figure && !requireNamespace("viridis", quietly = TRUE))
stop("Please install the 'viridis' package.")
## --- input checks (unchanged) -----------------------------------------
if (!is.matrix(distance_matrix) && !inherits(distance_matrix, "dist"))
stop("distance_matrix must be matrix or 'dist'.")
if (inherits(distance_matrix, "dist"))
distance_matrix <- as.matrix(distance_matrix)
stopifnot(nrow(distance_matrix) == length(trait))
## --- PCoA --------------------------------------------------------------
pcoa_obj <- cmdscale(distance_matrix, k = ndim, eig = TRUE)
E        <- pcoa_obj$points
eigvals  <- pcoa_obj$eig
var_expl <- eigvals / sum(eigvals[eigvals > 0])
## --- choose projection algorithm --------------------------------------
y_vec <- if (method == "spearman") rank(trait) else trait
v_hat <- solve(t(E) %*% E, t(E) %*% y_vec)   # general: (EᵀE)⁻¹Eᵀy*
proj  <- as.vector(E %*% v_hat)
## --- global linear R² on raw trait (still informative) ----------------
lm_fit        <- lm(trait ~ E)
adj_r2        <- summary(lm_fit)$adj.r.squared
p_val         <- pf(summary(lm_fit)$fstatistic[1],
summary(lm_fit)$fstatistic[2],
summary(lm_fit)$fstatistic[3],
lower.tail = FALSE)
## --- plotting ----------------------------------------------------------
p <- NULL
if (figure) {
df <- data.frame(PCoA1 = E[, 1], PCoA2 = E[, 2], Projection = proj)
p <- ggplot2::ggplot(df,
ggplot2::aes(PCoA1, PCoA2, color = Projection)) +
ggplot2::geom_point(size = 3, alpha = 0.85) +
viridis::scale_color_viridis(option = "plasma",
direction = -1,
name = paste("Projection (", method, ")")) +
ggplot2::labs(
title = "PCoA coloured by projection scores",
x     = sprintf("PCoA1 (%.1f%%)", var_expl[1] * 100),
y     = sprintf("PCoA2 (%.1f%%)", var_expl[2] * 100)
) +
ggplot2::theme_classic(base_size = 14)
print(p)
}
list(
projection_scores  = proj,
gradient_direction = v_hat,
PCoA_coordinates   = E,
adjusted_R2        = adj_r2,
p_value            = p_val,
method             = method,
plot               = p,
variance_explained = var_expl
)
}
gradient_projection(dist_bray_filt, age_filt)
#' Gradient projection using PLS-1 (best-practice version)
#'
#' Identical interface to your original `gradient_projection()` but the
#' direction is obtained from a single-component PLS (SIMPLS algorithm via
#' the \pkg{pls} package).  Everything else—R², p-value, plot—remains the same.
#'
#' @importFrom pls plsr loading.weights scores
#' @export
gradient_projection_pls <- function(distance_matrix,
trait,
ndim   = 5,
figure = TRUE) {
## --- dependencies ------------------------------------------------------
if (!requireNamespace("vegan", quietly = TRUE))
stop("Please install the 'vegan' package.")
if (!requireNamespace("pls", quietly = TRUE))
stop("Please install the 'pls' package.")
if (figure && !requireNamespace("ggplot2", quietly = TRUE))
stop("Please install the 'ggplot2' package.")
if (figure && !requireNamespace("viridis", quietly = TRUE))
stop("Please install the 'viridis' package.")
## --- input checks ------------------------------------------------------
if (!is.matrix(distance_matrix) && !inherits(distance_matrix, "dist"))
stop("distance_matrix must be matrix or 'dist'.")
if (inherits(distance_matrix, "dist"))
distance_matrix <- as.matrix(distance_matrix)
stopifnot(nrow(distance_matrix) == length(trait))
## --- PCoA --------------------------------------------------------------
pcoa_obj <- cmdscale(distance_matrix, k = ndim, eig = TRUE)
E        <- pcoa_obj$points
eigvals  <- pcoa_obj$eig
var_expl <- eigvals / sum(eigvals[eigvals > 0])
## --- PLS-1 projection --------------------------------------------------
pls_mod <- pls::plsr(trait ~ E, ncomp = 1, validation = "none")
v_hat   <- drop(pls::loading.weights(pls_mod)[, 1])      # direction vector
proj    <- drop(pls::scores(pls_mod)[, 1])               # projection scores
## --- global OLS fit for reference -------------------------------------
lm_fit  <- lm(trait ~ E)
fstat   <- summary(lm_fit)$fstatistic
p_val   <- pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
adj_r2  <- summary(lm_fit)$adj.r.squared
## --- plot --------------------------------------------------------------
p <- NULL
if (figure) {
df <- data.frame(PCoA1 = E[, 1], PCoA2 = E[, 2], Projection = proj)
p  <- ggplot2::ggplot(df,
ggplot2::aes(PCoA1, PCoA2, color = Projection)) +
ggplot2::geom_point(size = 3, alpha = 0.9) +
viridis::scale_color_viridis(option = "plasma",
direction = -1,
name = "PLS projection") +
ggplot2::labs(
title = "PCoA coloured by PLS-1 projection",
x     = sprintf("PCoA1 (%.1f%%)", var_expl[1] * 100),
y     = sprintf("PCoA2 (%.1f%%)", var_expl[2] * 100)
) +
ggplot2::theme_classic(base_size = 14)
print(p)
}
## --- return ------------------------------------------------------------
list(
projection_scores  = proj,
gradient_direction = v_hat,
PCoA_coordinates   = E,
adjusted_R2        = adj_r2,
p_value            = p_val,
method             = "pls1",
plot               = p,
variance_explained = var_expl
)
}
gradient_projection(dist_bray_filt, age_filt)
load("Ocean.RData")
View(ps)
ps@sam_data[["Longitude"]]
ps@sam_data[["Latitude"]]
Depth.nominal <- as.numeric(sample_data(ps)[["Depth.nominal"]])
keep <- !is.na(Depth.nominal)
ps_filt <- prune_samples(keep, ps)
Depth.nominal_filt <- as.numeric(sample_data(ps_filt)[["Depth.nominal"]])
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, Depth.nominal_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
cjtt_u_test(dist_bray_filt, Depth.nominal_filt, var_method = "analytic")
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
summary(ps@sam_data[["Longitude"]])
Longitude <- as.numeric(sample_data(ps)[["Longitude"]])
keep <- !is.na(Longitude)
ps_filt <- prune_samples(keep, ps)
Longitude_filt <- as.numeric(sample_data(ps_filt)[["Longitude"]])
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, Longitude_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
cjtt_u_test(dist_bray_filt, Longitude_filt, var_method = "analytic")
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
summary(ps@sam_data[["Latitude"]])
Latitude <- as.numeric(sample_data(ps)[["Latitude"]])
keep <- !is.na(Latitude)
ps_filt <- prune_samples(keep, ps)
Latitude_filt <- as.numeric(sample_data(ps_filt)[["Latitude"]])
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, Latitude_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
cjtt_u_test(dist_bray_filt, Latitude_filt, var_method = "analytic")
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
ps@sam_data[["Gradient.Surface.temp(SST)"]]
ps@sam_data[["Density"]]
Density <- as.numeric(sample_data(ps)[["Density"]])
keep <- !is.na(Density)
ps_filt <- prune_samples(keep, ps)
Density_filt <- as.numeric(sample_data(ps_filt)[["Density"]])
dist_bray_filt <- phyloseq::distance(ps_filt, method = "bray")
res <- BetaTREND::gradient_projection(dist_bray_filt, Density_filt)
res
evaluate_consistency_metrics(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
cjtt_u_test(dist_bray_filt, Density_filt, var_method = "analytic")
gco_decomposition(pcoa_mat = res$PCoA_coordinates,projection_scores = res$projection_scores)
