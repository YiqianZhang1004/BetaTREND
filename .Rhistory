}
# --- Step 1: Compute sample-level dispersion (distance to others) ---
dispersion <- rowSums(dist_matrix) / (n - 1)
# --- Step 2: Compute U-statistic ---
combs <- combn(n, 2)
signs <- apply(combs, 2, function(idx) {
i <- idx[1]; j <- idx[2]
sign(trait[j] - trait[i]) * sign(dispersion[j] - dispersion[i])
})
U <- mean(signs)
# --- Step 3: Permutation test (if selected) ---
if (permutation) {
perm_U <- numeric(B)
for (b in 1:B) {
perm_trait <- sample(trait)
signs_b <- apply(combs, 2, function(idx) {
i <- idx[1]; j <- idx[2]
sign(perm_trait[j] - perm_trait[i]) * sign(dispersion[j] - dispersion[i])
})
perm_U[b] <- mean(signs_b)
}
p_val <- mean(abs(perm_U) >= abs(U))
return(list(
U_statistic = U,
variance = NA,
z_score = NA,
p_value = p_val,
method = "permutation"
))
}
# --- Step 4: Variance estimation ---
if (var_method == "analytic") {
var_hat <- (4 * (n - 2)) / (9 * n * (n - 1))
}
if (var_method == "jackknife") {
U_i <- numeric(n)
for (i in 1:n) {
idx <- setdiff(1:n, i)
trait_i <- trait[idx]
disp_i <- dispersion[idx]
combs_i <- combn(n - 1, 2)
signs_i <- apply(combs_i, 2, function(k) {
a <- k[1]; b <- k[2]
sign(trait_i[b] - trait_i[a]) * sign(disp_i[b] - disp_i[a])
})
U_i[i] <- mean(signs_i)
}
U_bar <- mean(U_i)
var_hat <- (n - 1) / n * sum((U_i - U_bar)^2)
}
if (var_method == "bootstrap") {
U_b <- numeric(B)
for (b in 1:B) {
idx <- sample(1:n, n, replace = TRUE)
trait_b <- trait[idx]
disp_b <- dispersion[idx]
combs_b <- combn(n, 2)
signs_b <- apply(combs_b, 2, function(idx2) {
i <- idx2[1]; j <- idx2[2]
sign(trait_b[j] - trait_b[i]) * sign(disp_b[j] - disp_b[i])
})
U_b[b] <- mean(signs_b)
}
var_hat <- var(U_b)
}
# --- Step 5: z-score and p-value ---
z <- U / sqrt(var_hat)
p_val <- 2 * (1 - pnorm(abs(z)))
return(list(
U_statistic = U,
variance = var_hat,
z_score = z,
p_value = p_val,
method = var_method
))
}
library(vegan)
# Simulate example
set.seed(1)
otu <- matrix(abs(rnorm(50 * 20)), nrow = 50)
trait <- seq(1, 50) + rnorm(50, 0, 2)
dist_mat <- vegdist(otu, method = "bray")
# Run CJTT-U with bootstrap variance
cjtt_u_test(dist_mat, trait, var_method = "bootstrap")
# Run CJTT-U with permutation test
cjtt_u_test(dist_mat, trait, permutation = TRUE)
cjtt_u_test(dist_mat, trait, var_method = "jackknife")
cjtt_u_test(dist_mat, trait, var_method = "analytic")
cjtt_u_test <- function(dist_matrix, trait, confounder = NULL,
var_method = c("analytic", "jackknife", "bootstrap"),
permutation = FALSE, B = 1000, seed = 123) {
set.seed(seed)
var_method <- match.arg(var_method)
n <- length(trait)
# --- Input checks ---
if (!is.matrix(dist_matrix) && !inherits(dist_matrix, "dist")) {
stop("dist_matrix must be a matrix or 'dist' object.")
}
if (inherits(dist_matrix, "dist")) {
dist_matrix <- as.matrix(dist_matrix)
}
if (nrow(dist_matrix) != n) {
stop("Trait length must match number of samples in distance matrix.")
}
# --- Optional: FWL residualization ---
if (!is.null(confounder)) {
Z <- as.matrix(confounder)
H <- Z %*% solve(t(Z) %*% Z) %*% t(Z)
P <- diag(n) - H
trait <- as.numeric(P %*% trait)
dist_matrix <- P %*% dist_matrix %*% P
}
# --- Step 1: Compute sample-level dispersion (distance to others) ---
dispersion <- rowSums(dist_matrix) / (n - 1)
# --- Step 2: Compute U-statistic ---
combs <- combn(n, 2)
signs <- apply(combs, 2, function(idx) {
i <- idx[1]; j <- idx[2]
sign(trait[j] - trait[i]) * sign(dispersion[j] - dispersion[i])
})
U <- mean(signs)
# --- Step 3: Permutation test (if selected) ---
if (permutation) {
perm_U <- numeric(B)
for (b in 1:B) {
perm_trait <- sample(trait)
signs_b <- apply(combs, 2, function(idx) {
i <- idx[1]; j <- idx[2]
sign(perm_trait[j] - perm_trait[i]) * sign(dispersion[j] - dispersion[i])
})
perm_U[b] <- mean(signs_b)
}
p_val <- mean(abs(perm_U) >= abs(U))
return(list(
U_statistic = U,
variance = NA,
z_score = NA,
p_value = p_val,
method = "permutation"
))
}
# --- Step 4: Variance estimation ---
if (var_method == "analytic") {
var_hat <- (4 * (n - 2)) / (9 * n * (n - 1))
}
if (var_method == "jackknife") {
U_i <- numeric(n)
for (i in 1:n) {
idx <- setdiff(1:n, i)
trait_i <- trait[idx]
disp_i <- dispersion[idx]
combs_i <- combn(n - 1, 2)
signs_i <- apply(combs_i, 2, function(k) {
a <- k[1]; b <- k[2]
sign(trait_i[b] - trait_i[a]) * sign(disp_i[b] - disp_i[a])
})
U_i[i] <- mean(signs_i)
}
U_bar <- mean(U_i)
var_hat <- (n - 1) / n * sum((U_i - U_bar)^2)
}
if (var_method == "bootstrap") {
U_b <- numeric(B)
for (b in 1:B) {
idx <- sample(1:n, n, replace = TRUE)
trait_b <- trait[idx]
disp_b <- dispersion[idx]
combs_b <- combn(n, 2)
signs_b <- apply(combs_b, 2, function(idx2) {
i <- idx2[1]; j <- idx2[2]
sign(trait_b[j] - trait_b[i]) * sign(disp_b[j] - disp_b[i])
})
U_b[b] <- mean(signs_b)
}
var_hat <- var(U_b)
}
# --- Step 5: z-score and p-value ---
z <- U / sqrt(var_hat)
p_val <- 2 * (1 - pnorm(abs(z)))
return(list(
U_statistic = U,
variance = var_hat,
z_score = z,
p_value = p_val,
method = var_method
))
}
cjtt_u_test(dist_mat, trait, var_method = "analytic")
cjtt_u_test(dist_mat, trait, permutation = TRUE)
gradient_projection <- function(distance_matrix, trait, ndim = 5, figure = TRUE) {
# Load required packages
if (!requireNamespace("vegan", quietly = TRUE)) stop("Please install the 'vegan' package.")
if (figure && !requireNamespace("ggplot2", quietly = TRUE)) stop("Please install the 'ggplot2' package.")
# Input checks
if (!is.matrix(distance_matrix) && !inherits(distance_matrix, "dist")) {
stop("distance_matrix must be a matrix or 'dist' object.")
}
n <- length(trait)
if (inherits(distance_matrix, "dist")) {
if (attr(distance_matrix, "Size") != n) stop("trait length must match number of samples.")
} else {
if (nrow(distance_matrix) != n) stop("trait length must match number of samples.")
}
# Step 1: PCoA with eigenvalues
pcoa_obj <- cmdscale(distance_matrix, k = ndim, eig = TRUE)
E <- pcoa_obj$points  # coordinates
eigvals <- pcoa_obj$eig
# Variance explained by first two axes
var_explained <- eigvals / sum(eigvals[eigvals > 0])  # only positive eigenvalues
var1 <- round(var_explained[1] * 100, 1)
var2 <- round(var_explained[2] * 100, 1)
# Step 2: Gradient direction
v_hat <- solve(t(E) %*% E) %*% t(E) %*% trait
y_hat <- as.vector(E %*% v_hat)
# Step 3: Linear model fit and p-value
lm_fit <- lm(trait ~ E)
fstat <- summary(lm_fit)$fstatistic
p_value <- pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
adj_r_squared <- summary(lm_fit)$adj.r.squared
# Step 4: Optional figure
p <- NULL
if (figure) {
plot_df <- data.frame(
PCoA1 = E[, 1],
PCoA2 = E[, 2],
ColorValue = if (p_value < 0.05) y_hat else trait
)
color_label <- if (p_value < 0.05) "Projection" else "Trait"
p <- ggplot2::ggplot(plot_df, ggplot2::aes(x = PCoA1, y = PCoA2, color = ColorValue)) +
ggplot2::geom_point(size = 2.5) +
ggplot2::scale_color_gradient(low = "blue", high = "red") +
ggplot2::labs(
title = paste("PCoA colored by", color_label),
x = paste0("PCoA1 (", var1, "%)"),
y = paste0("PCoA2 (", var2, "%)"),
color = color_label
) +
ggplot2::theme_minimal()
print(p)
}
return(list(
projection_scores = y_hat,
gradient_direction = v_hat,
PCoA_coordinates = E,
adjusted_R2 = adj_r_squared,
p_value = p_value,
plot = p,
variance_explained = var_explained
))
}
# Simulate example data
set.seed(42)
n <- 50  # number of samples
# Create a random distance matrix (Euclidean)
coords <- matrix(rnorm(n * 5), ncol = 5)
distance_matrix <- dist(coords)
# Simulate a trait that may or may not align with the gradient
trait <- rnorm(n)
# Load required packages
library(ggplot2)
library(vegan)
# Run the gradient projection function
result <- gradient_projection(distance_matrix, trait, ndim = 5, figure = TRUE)
# Output key results
print(result$adjusted_R2)
print(result$p_value)
install.packages("viridis")
gradient_projection <- function(distance_matrix, trait, ndim = 5, figure = TRUE) {
# Load required packages
if (!requireNamespace("vegan", quietly = TRUE)) stop("Please install the 'vegan' package.")
if (figure && !requireNamespace("ggplot2", quietly = TRUE)) stop("Please install the 'ggplot2' package.")
# Input checks
if (!is.matrix(distance_matrix) && !inherits(distance_matrix, "dist")) {
stop("distance_matrix must be a matrix or 'dist' object.")
}
n <- length(trait)
if (inherits(distance_matrix, "dist")) {
if (attr(distance_matrix, "Size") != n) stop("trait length must match number of samples.")
} else {
if (nrow(distance_matrix) != n) stop("trait length must match number of samples.")
}
# Step 1: PCoA with eigenvalues
pcoa_obj <- cmdscale(distance_matrix, k = ndim, eig = TRUE)
E <- pcoa_obj$points  # coordinates
eigvals <- pcoa_obj$eig
# Variance explained by first two axes
var_explained <- eigvals / sum(eigvals[eigvals > 0])  # only positive eigenvalues
var1 <- round(var_explained[1] * 100, 1)
var2 <- round(var_explained[2] * 100, 1)
# Step 2: Gradient direction
v_hat <- solve(t(E) %*% E) %*% t(E) %*% trait
y_hat <- as.vector(E %*% v_hat)
# Step 3: Linear model fit and p-value
lm_fit <- lm(trait ~ E)
fstat <- summary(lm_fit)$fstatistic
p_value <- pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
adj_r_squared <- summary(lm_fit)$adj.r.squared
# Step 4: Optional figure
p <- NULL
if (figure) {
library(ggplot2)
library(viridis)
plot_df <- data.frame(
PCoA1 = E[, 1],
PCoA2 = E[, 2],
Trait = trait,
Projection = y_hat
)
color_by <- if (p_val < 0.05) "Projection" else "Trait"
plot_df$Color <- if (color_by == "Projection") y_hat else trait
p <- ggplot(plot_df, aes(x = PCoA1, y = PCoA2, color = Color)) +
geom_point(size = 3, alpha = 0.85) +
scale_color_viridis(option = "plasma", direction = -1, name = color_by) +
labs(
title = "Gradient-Aligned Projection in PCoA Space",
subtitle = if (color_by == "Projection") "Colored by projection scores" else "Colored by trait values",
x = paste0("PCoA1 (", var1, "%)"),
y = paste0("PCoA2 (", var2, "%)")
) +
theme_minimal(base_size = 16) +
theme(
plot.title = element_text(face = "bold", size = 18),
plot.subtitle = element_text(size = 14, margin = margin(b = 10)),
axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
print(p)
}
return(list(
projection_scores = y_hat,
gradient_direction = v_hat,
PCoA_coordinates = E,
adjusted_R2 = adj_r_squared,
p_value = p_value,
plot = p,
variance_explained = var_explained
))
}
# Simulate example data
set.seed(42)
n <- 50  # number of samples
# Create a random distance matrix (Euclidean)
coords <- matrix(rnorm(n * 5), ncol = 5)
distance_matrix <- dist(coords)
# Simulate a trait that may or may not align with the gradient
trait <- rnorm(n)
# Load required packages
library(ggplot2)
library(vegan)
# Run the gradient projection function
result <- gradient_projection(distance_matrix, trait, ndim = 5, figure = TRUE)
gradient_projection <- function(distance_matrix, trait, ndim = 5, figure = TRUE) {
# Load required packages
if (!requireNamespace("vegan", quietly = TRUE)) stop("Please install the 'vegan' package.")
if (figure && !requireNamespace("ggplot2", quietly = TRUE)) stop("Please install the 'ggplot2' package.")
# Input checks
if (!is.matrix(distance_matrix) && !inherits(distance_matrix, "dist")) {
stop("distance_matrix must be a matrix or 'dist' object.")
}
n <- length(trait)
if (inherits(distance_matrix, "dist")) {
if (attr(distance_matrix, "Size") != n) stop("trait length must match number of samples.")
} else {
if (nrow(distance_matrix) != n) stop("trait length must match number of samples.")
}
# Step 1: PCoA with eigenvalues
pcoa_obj <- cmdscale(distance_matrix, k = ndim, eig = TRUE)
E <- pcoa_obj$points  # coordinates
eigvals <- pcoa_obj$eig
# Variance explained by first two axes
var_explained <- eigvals / sum(eigvals[eigvals > 0])  # only positive eigenvalues
var1 <- round(var_explained[1] * 100, 1)
var2 <- round(var_explained[2] * 100, 1)
# Step 2: Gradient direction
v_hat <- solve(t(E) %*% E) %*% t(E) %*% trait
y_hat <- as.vector(E %*% v_hat)
# Step 3: Linear model fit and p-value
lm_fit <- lm(trait ~ E)
fstat <- summary(lm_fit)$fstatistic
p_value <- pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
adj_r_squared <- summary(lm_fit)$adj.r.squared
# Step 4: Optional figure
p <- NULL
if (figure) {
library(ggplot2)
library(viridis)
plot_df <- data.frame(
PCoA1 = E[, 1],
PCoA2 = E[, 2],
Trait = trait,
Projection = y_hat
)
color_by <- if (p_value < 0.05) "Projection" else "Trait"
plot_df$Color <- if (color_by == "Projection") y_hat else trait
p <- ggplot(plot_df, aes(x = PCoA1, y = PCoA2, color = Color)) +
geom_point(size = 3, alpha = 0.85) +
scale_color_viridis(option = "plasma", direction = -1, name = color_by) +
labs(
title = "Gradient-Aligned Projection in PCoA Space",
subtitle = if (color_by == "Projection") "Colored by projection scores" else "Colored by trait values",
x = paste0("PCoA1 (", var1, "%)"),
y = paste0("PCoA2 (", var2, "%)")
) +
theme_minimal(base_size = 16) +
theme(
plot.title = element_text(face = "bold", size = 18),
plot.subtitle = element_text(size = 14, margin = margin(b = 10)),
axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
print(p)
}
return(list(
projection_scores = y_hat,
gradient_direction = v_hat,
PCoA_coordinates = E,
adjusted_R2 = adj_r_squared,
p_value = p_value,
plot = p,
variance_explained = var_explained
))
}
# Simulate example data
set.seed(42)
n <- 50  # number of samples
# Create a random distance matrix (Euclidean)
coords <- matrix(rnorm(n * 5), ncol = 5)
distance_matrix <- dist(coords)
# Simulate a trait that may or may not align with the gradient
trait <- rnorm(n)
# Load required packages
library(ggplot2)
library(vegan)
# Run the gradient projection function
result <- gradient_projection(distance_matrix, trait, ndim = 5, figure = TRUE)
# Output key results
print(result$adjusted_R2)
print(result$p_value)
# Simulate example data
set.seed(42)
n <- 50  # number of samples
# Create a random distance matrix (Euclidean)
coords <- matrix(rnorm(n * 5), ncol = 5)
distance_matrix <- dist(coords)
# Simulate a trait that may or may not align with the gradient
trait <- rnorm(n)
# Load required packages
library(ggplot2)
library(vegan)
# Run the gradient projection function
result <- gradient_projection(distance_matrix, trait, ndim = 5, figure = TRUE)
# Output key results
print(result$adjusted_R2)
print(result$p_value)
# Simulate example data
set.seed(2025)
n <- 100  # number of samples
# Create a random distance matrix (Euclidean)
coords <- matrix(rnorm(n * 5), ncol = 5)
distance_matrix <- dist(coords)
# Simulate a trait that may or may not align with the gradient
trait <- rnorm(n)
# Load required packages
library(ggplot2)
library(vegan)
# Run the gradient projection function
result <- gradient_projection(distance_matrix, trait, ndim = 5, figure = TRUE)
# Output key results
print(result$adjusted_R2)
print(result$p_value)
# Simulate example data
set.seed(42)
n <- 5000  # number of samples
# Create a random distance matrix (Euclidean)
coords <- matrix(rnorm(n * 5), ncol = 5)
distance_matrix <- dist(coords)
# Simulate a trait that may or may not align with the gradient
trait <- rnorm(n)
# Load required packages
library(ggplot2)
library(vegan)
# Run the gradient projection function
result <- gradient_projection(distance_matrix, trait, ndim = 5, figure = TRUE)
# Output key results
print(result$adjusted_R2)
print(result$p_value)
setwd("~/Desktop/BetaTREND")
devtools::document()
document()
devtools::document()
devtools::document()
devtools::install()
devtools::check()
rm(c("cjtt_u_test",
"evaluate_consistency_metrics",
"gco_decomposition",
"gradient_projection"))
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
